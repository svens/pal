#pragma once // -*- C++ -*-

/**
 * \file pal/conv
 * Encoding/decoding functions (base64, hex)
 */

#include <pal/__bits/lib>
#include <system_error>
#include <span>


__pal_begin


/**
 * Encoding/decoding conversion result.
 */
struct conv_result
{
	/// Last read position.
	const char *last_in;

	/// Last write position.
	char *last_out;
};


// Base64 {{{1


/**
 * Return maximum output size when encoding \a input as Base64.
 */
template <typename T, size_t Extent>
constexpr size_t to_base64_size (const std::span<T, Extent> &input) noexcept
{
	return ((input.size_bytes() * 4 / 3) + 3) & ~3;
}


/**
 * Return maximum output size when decoding Base64 \a input or 0 if \a input
 * size is not valid encoded size.
 */
template <typename T, size_t Extent>
constexpr size_t from_base64_size (const std::span<T, Extent> &input) noexcept
{
	auto input_size = input.size_bytes();
	return input_size % 4 == 0 ? (input_size / 4 * 3) : 0;
}


/**
 * Encode range [\a first, \a last) as base64, writing result into \a out.
 * During conversion, there is no output range checking. It is application
 * responsibility to ensure sufficient output space using function
 * \c to_base64_size()
 *
 * On success, returns conv_result with \e last_in as last read position
 * (equals \a last), and \e last_out as last write position.
 */
conv_result to_base64 (const char *first, const char *last, char *out) noexcept;


/**
 * Decode base64-encoded blob in [\a first, \a last), writing result into \a out.
 * During conversion, there is no output range checking. It is application
 * responsibility to ensure there is sufficient output space using function
 * \c from_base64_size().
 *
 * On success, returns conv_result with \e last_in as last read position
 * (equals \a last), and \e last_out as last write position.
 *
 * On failure, \a last_in does not equal to \a last but points to erroneous
 * base64 value. \a last_out points to one past last successfully decoded
 * character position.
 */
conv_result from_base64 (const char *first, const char *last, char *out) noexcept;


// Hex {{{1


/**
 * Return maximum output size when encoding \a input as hex-string.
 */
template <typename T, size_t Extent>
constexpr size_t to_hex_size (const std::span<T, Extent> &input) noexcept
{
	return input.size_bytes() * 2;
}


/**
 * Return maximum output size when decoding hex-string \a input or 0 if \a
 * input size is not valid encoded size.
 */
template <typename T, size_t Extent>
constexpr size_t from_hex_size (const std::span<T, Extent> &input) noexcept
{
	auto input_size = input.size_bytes();
	return input_size % 2 == 0 ? input_size / 2 : 0;
}


/**
 * Encode range [\a first, \a last) as hex, writing result into \a out. During
 * conversion, there is no output range checking. It is application
 * responsibility to ensure sufficient output space using function
 * \c to_hex_size()
 *
 * On success, returns conv_result with \e last_in as last read position
 * (equals \a last), and \e last_out as last write position.
 */
conv_result to_hex (const char *first, const char *last, char *out) noexcept;


/**
 * Decode hex-encoded blob in [\a first, \a last), writing result into \a out.
 * During conversion, there is no output range checking. It is application
 * responsibility to ensure there is sufficient output space using function
 * \c from_hex_size().
 *
 * On success, returns conv_result with \e last_in as last read position
 * (equals \a last), and \e last_out as last write position.
 *
 * On failure, \a last_in does not equal to \a last but points to erroneous
 * hex value. \a last_out points to one past last successfully decoded
 * character position.
 */
conv_result from_hex (const char *first, const char *last, char *out) noexcept;


// }}}1


__pal_end
