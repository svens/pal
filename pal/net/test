#pragma once // -*- C++ -*-

#include <pal/test>
#include <pal/net/internet>
#include <pal/net/socket>

namespace pal_test {

struct udp_v4
{
	static constexpr auto protocol_v = pal::net::ip::udp::v4();
	static constexpr auto loopback_v = pal::net::ip::address_v4::loopback();

	static auto make_socket () noexcept
	{
		return pal::net::make_datagram_socket(protocol_v);
	}
};

struct udp_v6
{
	static constexpr auto protocol_v = pal::net::ip::udp::v6();
	static constexpr auto loopback_v = pal::net::ip::address_v6::loopback();

	static auto make_socket () noexcept
	{
		return pal::net::make_datagram_socket(protocol_v);
	}
};

struct tcp_v4
{
	static constexpr auto protocol_v = pal::net::ip::tcp::v4();
	static constexpr auto loopback_v = pal::net::ip::address_v4::loopback();

	static auto make_socket () noexcept
	{
		return pal::net::make_stream_socket(protocol_v);
	}
};

struct tcp_v6
{
	static constexpr auto protocol_v = pal::net::ip::tcp::v6();
	static constexpr auto loopback_v = pal::net::ip::address_v6::loopback();

	static auto make_socket () noexcept
	{
		return pal::net::make_stream_socket(protocol_v);
	}
};

template <typename Protocol>
struct v6_only: Protocol
{
};

using udp_v6_only = v6_only<udp_v6>;
using tcp_v6_only = v6_only<tcp_v6>;

template <typename T>
constexpr bool is_udp_v = false
	|| std::is_same_v<T, udp_v4>
	|| std::is_same_v<T, udp_v6>
	|| std::is_same_v<T, udp_v6_only>
;

template <typename T>
constexpr bool is_tcp_v = false
	|| std::is_same_v<T, tcp_v4>
	|| std::is_same_v<T, tcp_v6>
	|| std::is_same_v<T, tcp_v6_only>
;

template <typename T>
constexpr bool is_v4_v = false
	|| std::is_same_v<T, udp_v4>
	|| std::is_same_v<T, tcp_v4>
;

template <typename T>
constexpr bool is_v6_v = false
	|| std::is_same_v<T, udp_v6>
	|| std::is_same_v<T, udp_v6_only>
	|| std::is_same_v<T, tcp_v6>
	|| std::is_same_v<T, tcp_v6_only>
;

} // namespace pal_test
