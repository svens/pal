#pragma once // -*- C++ -*-

/**
 * \file pal/net/basic_datagram_socket
 * Generic datagram-oriented socket
 */

#include <pal/__bits/lib>
#include <pal/net/error>
#include <pal/net/basic_socket>


__pal_begin


namespace net {


/**
 * Datagram socket that can be used to send and receive discrete messages of
 * fixed maximum length.
 */
template <typename Protocol>
class basic_datagram_socket: public basic_socket<Protocol>
{
	using base = basic_socket<Protocol>;

public:

	/// Socket protocol
	using protocol_type = Protocol;

	/// Socket endpoint
	using endpoint_type = typename protocol_type::endpoint;

	/// Native socket handle
	using typename base::native_handle_type;


	/**
	 * Create new unopened socket.
	 */
	basic_datagram_socket () noexcept = default;


	/**
	 * Create new socket, acquiring native_sockte.
	 */
	basic_datagram_socket (const protocol_type &protocol, native_handle_type handle)
		: base(protocol, handle)
	{ }


	/**
	 * Create new socket and open it.
	 */
	basic_datagram_socket (const protocol_type &protocol)
		: base(protocol)
	{ }


	/**
	 * Construct and open new socket. After construction bind to \a
	 * endpoint. On failure, throw std::system_error.
	 */
	basic_datagram_socket (const endpoint_type &endpoint)
		: base(endpoint)
	{ }


	//
	// receive_from
	//


	/**
	 * Read data from socket into \a buffers. Source endpoint is stored
	 * into \a sender. Returns number of bytes received. On failure, set
	 * \a error and return value is undefined.
	 */
	template <typename MutableBufferSequence>
	size_t receive_from (const MutableBufferSequence &buffers,
		endpoint_type &sender,
		socket_base::message_flags flags,
		std::error_code &error) noexcept
	{
		__bits::message message(buffers, sender.data(), sender.capacity());
		auto result = base::socket_.receive(message, flags, error);
		if (result >= 0)
		{
			sender.resize(message.msg_namelen, error);
		}
		return result;
	}


	/**
	 * Read data from socket into \a buffers. Source endpoint is stored
	 * into \a sender. Returns number of bytes received. On failure throws
	 * std::system_error.
	 */
	template <typename MutableBufferSequence>
	size_t receive_from (const MutableBufferSequence &buffers,
		endpoint_type &sender,
		socket_base::message_flags flags)
	{
		return receive_from(
			buffers,
			sender,
			flags,
			throw_on_error("basic_datagram_socket::receive_from")
		);
	}


	/**
	 * Read data from socket into \a buffers. Source endpoint is stored
	 * into \a sender. Returns number of bytes received. On failure, set
	 * \a error and return value is undefined.
	 */
	template <typename MutableBufferSequence>
	size_t receive_from (const MutableBufferSequence &buffers,
		endpoint_type &sender,
		std::error_code &error) noexcept
	{
		return receive_from(
			buffers,
			sender,
			socket_base::message_flags{},
			error
		);
	}


	/**
	 * Read data from socket into \a buffers. Source endpoint is stored
	 * into \a sender. Returns number of bytes received. On failure throws
	 * std::system_error.
	 */
	template <typename MutableBufferSequence>
	size_t receive_from (const MutableBufferSequence &buffers,
		endpoint_type &sender)
	{
		return receive_from(
			buffers,
			sender,
			socket_base::message_flags{}
		);
	}


	//
	// send_to
	//


	/**
	 * Send data from \a buffers using this socket to \a recipient.
	 * Returns number of bytes sent. On failure set \a std::error and
	 * return value is undefined.
	 */
	template <typename ConstBufferSequence>
	size_t send_to (const ConstBufferSequence &buffers,
		const endpoint_type &recipient,
		socket_base::message_flags flags,
		std::error_code &error) noexcept
	{
		__bits::message message(buffers, recipient.data(), recipient.size());
		return base::socket_.send(message, flags, error);
	}


	/**
	 * Send data from \a buffers using this socket to \a recipient.
	 * Returns number of bytes sent. On failure, throw std::system_error.
	 */
	template <typename ConstBufferSequence>
	size_t send_to (const ConstBufferSequence &buffers,
		const endpoint_type &recipient,
		socket_base::message_flags flags)
	{
		return send_to(
			buffers,
			recipient,
			flags,
			throw_on_error("basic_datagram_socket::send_to")
		);
	}


	/**
	 * Send data from \a buffers using this socket to \a recipient.
	 * Returns number of bytes sent. On failure set \a std::error and
	 * return value is undefined.
	 */
	template <typename ConstBufferSequence>
	size_t send_to (const ConstBufferSequence &buffers,
		const endpoint_type &recipient,
		std::error_code &error) noexcept
	{
		return send_to(
			buffers,
			recipient,
			socket_base::message_flags{},
			error
		);
	}


	/**
	 * Send data from \a buffers using this socket to \a recipient.
	 * Returns number of bytes sent. On failure, throw std::system_error.
	 */
	template <typename ConstBufferSequence>
	size_t send_to (const ConstBufferSequence &buffers,
		const endpoint_type &recipient)
	{
		return send_to(
			buffers,
			recipient,
			socket_base::message_flags{}
		);
	}


	//
	// receive
	//


	/**
	 * Read data from socket into \a buffers. Returns number of bytes
	 * received. On failure, set \a error and return value is undefined.
	 *
	 * \note This operation can be used with connection-mode or
	 * connectionless-mode sockets, but it is normally used with
	 * connection-mode sockets because it does not permit application to
	 * retrieve the source endpoint of received data.
	 */
	template <typename MutableBufferSequence>
	size_t receive (const MutableBufferSequence &buffers,
		socket_base::message_flags flags,
		std::error_code &error) noexcept
	{
		__bits::message message(buffers);
		return base::socket_.receive(message, flags, error);
	}


	/**
	 * Read data from socket into \a buffers. Returns number of bytes
	 * received. On failure, throw std::system_error.
	 *
	 * \note This operation can be used with connection-mode or
	 * connectionless-mode sockets, but it is normally used with
	 * connection-mode sockets because it does not permit application to
	 * retrieve the source endpoint of received data.
	 */
	template <typename MutableBufferSequence>
	size_t receive (const MutableBufferSequence &buffers,
		socket_base::message_flags flags)
	{
		return receive(buffers, flags,
			throw_on_error("basic_datagram_socket::receive")
		);
	}


	/**
	 * Read data from socket into \a buffers. Returns number of bytes
	 * received. On failure, set \a error and return value is undefined.
	 *
	 * \note This operation can be used with connection-mode or
	 * connectionless-mode sockets, but it is normally used with
	 * connection-mode sockets because it does not permit application to
	 * retrieve the source endpoint of received data.
	 */
	template <typename MutableBufferSequence>
	size_t receive (const MutableBufferSequence &buffers,
		std::error_code &error) noexcept
	{
		return receive(buffers, socket_base::message_flags{}, error);
	}


	/**
	 * Read data from socket into \a buffers. Returns number of bytes
	 * received. On failure, throw std::system_error.
	 *
	 * \note This operation can be used with connection-mode or
	 * connectionless-mode sockets, but it is normally used with
	 * connection-mode sockets because it does not permit application to
	 * retrieve the source endpoint of received data.
	 */
	template <typename MutableBufferSequence>
	size_t receive (const MutableBufferSequence &buffers)
	{
		return receive(buffers, socket_base::message_flags{});
	}


	//
	// send
	//


	/**
	 * Send data from \a buffers using this socket. It can be used only
	 * with connection-mode sockets. Returns number of bytes sent. On
	 * failure set \a std::error and return value is undefined.
	 */
	template <typename ConstBufferSequence>
	size_t send (const ConstBufferSequence &buffers,
		socket_base::message_flags flags,
		std::error_code &error) noexcept
	{
		__bits::message message(buffers);
		return base::socket_.send(message, flags, error);
	}


	/**
	 * Send data from \a buffers using this socket. It can be used only
	 * with connection-mode sockets. Returns number of bytes sent. On
	 * failure throw std::system_error.
	 */
	template <typename ConstBufferSequence>
	size_t send (const ConstBufferSequence &buffers,
		socket_base::message_flags flags)
	{
		return send(buffers, flags,
			throw_on_error("basic_datagram_socket::send")
		);
	}


	/**
	 * Send data from \a buffers using this socket. It can be used only
	 * with connection-mode sockets. Returns number of bytes sent. On
	 * failure set \a std::error and return value is undefined.
	 */
	template <typename ConstBufferSequence>
	size_t send (const ConstBufferSequence &buffers,
		std::error_code &error) noexcept
	{
		return send(buffers, socket_base::message_flags{}, error);
	}


	/**
	 * Send data from \a buffers using this socket. It can be used only
	 * with connection-mode sockets. Returns number of bytes sent. On
	 * failure throw std::system_error.
	 */
	template <typename ConstBufferSequence>
	size_t send (const ConstBufferSequence &buffers)
	{
		return send(buffers, socket_base::message_flags{});
	}
};


} // namespace net


__pal_end
