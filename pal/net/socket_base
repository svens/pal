#pragma once // -*- C++ -*-

/**
 * \file pal/net/socket_base
 * Base socket types and values
 */

#include <pal/__bits/lib>
#include <pal/net/__bits/socket>
#include <pal/net/error>
#include <chrono>


__pal_begin


namespace net {


/**
 * Initialize socket library. There is no need to call it explicitly as it is
 * also done internally by static initialization. Only exception is when
 * application layer own static initialization order depends on winsock
 * library to be already loaded. It can be called multiple times.
 *
 * \c std::call_once is used to make sure only single call proceeds.
 */
inline const std::error_code &init () noexcept
{
	return __bits::init();
}


/**
 * Socket option value of type \a T
 */
template <typename T>
struct socket_option_value
{
	socket_option_value () noexcept = default;


	/**
	 * Constructs socket option object with \a value.
	 */
	explicit socket_option_value (int value) noexcept
		: value_(value)
	{ }


	/**
	 * \returns current integer value of the socket option object.
	 */
	int value () const noexcept
	{
		return value_;
	}


	/**
	 * Return pointer to value storage.
	 */
	template <typename Protocol>
	void *data (const Protocol &) noexcept
	{
		return std::addressof(value_);
	}


	/**
	 * Return pointer to value storage.
	 */
	template <typename Protocol>
	const void *data (const Protocol &) const noexcept
	{
		return std::addressof(value_);
	}


	/**
	 * Return value storage size (in bytes).
	 */
	template <typename Protocol>
	size_t size (const Protocol &) const noexcept
	{
		return sizeof(value_);
	}


	/**
	 * Set new size for socket option value storage. This method is no-op
	 * and it sets error if \a size is different from size() return value.
	 */
	template <typename Protocol>
	void resize (const Protocol &, size_t size, std::error_code &error) noexcept
	{
		if (size == sizeof(value_))
		{
			error.clear();
		}
		else
		{
			error = make_error_code(socket_errc::socket_option_length_error);
		}
	}


	/**
	 * Set new size for socket option value storage. This method is no-op
	 * and it throws std::length_error if \a size is different from size()
	 * return value.
	 */
	template <typename Protocol>
	void resize (const Protocol &, size_t size)
	{
		if (size != sizeof(value_))
		{
			throw std::length_error("socket_option::resize");
		}
	}


protected:

	/**
	 * Socket option value storage
	 */
	T value_{};
};


/**
 * Boolean socket option value.
 */
template <>
struct socket_option_value<bool>: socket_option_value<int>
{
public:

	socket_option_value () noexcept = default;


	/**
	 * Constructs socket option object with \a value.
	 */
	explicit socket_option_value (bool value) noexcept
		: socket_option_value<int>(value)
	{ }


	/**
	 * \returns current boolean value of the socket option object.
	 */
	bool value () const noexcept
	{
		return socket_option_value<int>::value_;
	}


	/**
	 * \returns value()
	 */
	explicit operator bool () const noexcept
	{
		return value();
	}


	/**
	 * \returns !value()
	 */
	bool operator! () const noexcept
	{
		return !value();
	}
};


/**
 * Generic socket option \a Name of type T on \a Level.
 */
template <typename T, int Level, int Name>
struct socket_option: socket_option_value<T>
{
	using socket_option_value<T>::socket_option_value;


	/**
	 * Sets new \a value for socket option object.
	 */
	socket_option &operator= (T value) noexcept
	{
		socket_option_value<T>::value_ = value;
		return *this;
	}


	/**
	 * \returns socket option level
	 */
	template <typename Protocol>
	int level (const Protocol &) const noexcept
	{
		return Level;
	}


	/**
	 * \returns socket option name
	 */
	template <typename Protocol>
	int name (const Protocol &) const noexcept
	{
		return Name;
	}
};


/// Common socket types and constants.
class socket_base
{
public:

	/// Native socket handle type
	using native_handle_type = __bits::native_socket;

	/// Invalid native socket handle
	static constexpr native_handle_type invalid = __bits::invalid_native_socket;


	/// \{
	/// Socket shutdown types
	using shutdown_type = __bits::shutdown_type;
	/// Disable further receive operations
	static constexpr shutdown_type shutdown_receive = shutdown_type::receive;
	/// Disable further send operations
	static constexpr shutdown_type shutdown_send = shutdown_type::send;
	/// Disable furher send/receive operations
	static constexpr shutdown_type shutdown_both = shutdown_type::both;
	/// \}


	/// \{
	/// Socket state change waiting types
	using wait_type = __bits::wait_type;
	/// Wait for socket become readable
	static constexpr wait_type wait_read = wait_type::read;
	/// Wait for socket become writable
	static constexpr wait_type wait_write = wait_type::write;
	/// Wait until socket has pending error condition
	static constexpr wait_type wait_error = wait_type::error;
	/// \}


	/// \{
	/// Bitmask flags for send/receive functions
	using message_flags = __bits::message_flags;
	/// Leave received data in queue
	static constexpr message_flags message_peek = MSG_PEEK;
	/// Out-of-band data
	static constexpr message_flags message_out_of_band = MSG_OOB;
	/// Send without using routing tables
	static constexpr message_flags message_do_not_route = MSG_DONTROUTE;
	/// \}


	/// Limit on length of queue of pending incoming connections
	static constexpr int max_listen_connections = SOMAXCONN;


	/// \defgroup socket_option Socket options
	/// \{

	/**
	 * Determines whether a socket permits sending of broadcast messages,
	 * if supported by the protocol.
	 */
	using broadcast = socket_option<bool, SOL_SOCKET, SO_BROADCAST>;

	/**
	 * Determines whether debugging information is recorded by the
	 * underlying protocol.
	 */
	using debug = socket_option<bool, SOL_SOCKET, SO_DEBUG>;

	/**
	 * Determines whether outgoing messages bypass standard routing
	 * facilities.
	 */
	using do_not_route = socket_option<bool, SOL_SOCKET, SO_DONTROUTE>;

	/**
	 * Determines whether socket permits sending of keep_alive messages,
	 * if supported by the protocol.
	 */
	using keepalive = socket_option<bool, SOL_SOCKET, SO_KEEPALIVE>;

	/**
	 * Determines whether out-of-band data (also known as urgent data) is
	 * received inline.
	 */
	using out_of_band_inline = socket_option<bool, SOL_SOCKET, SO_OOBINLINE>;

	/**
	 * Determines whether the validation of endpoints used for binding a
	 * socket should allow the reuse of local endpoints, if supported by
	 * protocol.
	 */
	using reuse_address = socket_option<bool, SOL_SOCKET, SO_REUSEADDR>;

	/**
	 * Determines whether the validation of ports used for binding a
	 * socket should allow the reuse of local port, if supported by
	 * protocol.
	 */
	using reuse_port = socket_option<bool, SOL_SOCKET, __bits::reuse_port>;

	/**
	 * Specify the size of the receive buffer associated with socket.
	 */
	using receive_buffer_size = socket_option<int, SOL_SOCKET, SO_RCVBUF>;

	/**
	 * Specifies the minimum number of bytes to process for socket input
	 * operations.
	 */
	using receive_low_watermark = socket_option<int, SOL_SOCKET, SO_RCVLOWAT>;

	/**
	 * Specify the size of the send buffer associated with socket.
	 */
	using send_buffer_size = socket_option<int, SOL_SOCKET, SO_SNDBUF>;

	/**
	 * Specifies the minimum number of bytes to process for socket output
	 * operations.
	 */
	using send_low_watermark = socket_option<int, SOL_SOCKET, SO_SNDLOWAT>;

	struct linger;

	/// \}


protected:

	~socket_base () = default;
};


/**
 * \ingroup socket_option
 *
 * Controls the behaviour when a socket is closed and unsent data is present.
 */
struct socket_base::linger
	: public socket_option<::linger, SOL_SOCKET, SO_LINGER>
{
	linger () noexcept = default;


	/**
	 * Construct linger object with enabled() == \a e and timeout() == \a t
	 */
	linger (bool e, const std::chrono::seconds &t) noexcept
	{
		enabled(e);
		timeout(t);
	}


	/**
	 * \returns true if lingering is enabled.
	 */
	bool enabled () const noexcept
	{
		return value_.l_onoff;
	}


	/**
	 * Sets whether lingering is enabled.
	 */
	void enabled (bool e) noexcept
	{
		value_.l_onoff = e;
	}


	/**
	 * \returns lingering timeout in seconds.
	 */
	std::chrono::seconds timeout () const noexcept
	{
		return std::chrono::seconds{value_.l_linger};
	}


	/**
	 * Sets lingering timeout in seconds.
	 */
	void timeout (const std::chrono::seconds &t) noexcept
	{
		value_.l_linger = static_cast<decltype(value_.l_linger)>(t.count());
	}
};


} // namespace net


__pal_end
