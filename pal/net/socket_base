#pragma once // -*- C++ -*-

/**
 * \file pal/net/socket_base
 * Base socket types and values
 */

#include <pal/net/__socket>
#include <memory>

namespace pal::net {

/// Initialize networking library. There is no need to call it explicitly as
/// it is also invoked internally by static initialization. Possible exception
/// is when application layer own static initialization order depends on winsock
/// library being loaded. It can be safely called multiple times.
const result<void> &init () noexcept;

/// Bitmask flags for send/receive operations
enum message_flags: int
{
	/// Peek at incoming message, without removing it from queue
	peek = MSG_PEEK,

	/// Process out-of-band data
	out_of_band = MSG_OOB,

	/// Bypass routing, use direct interface
	do_not_route = MSG_DONTROUTE,

	/// Received message was truncated because receive buffer was too small
	truncated = MSG_TRUNC,
};

/// Socket state change waiting types
enum wait_type: int
{
	/// Wait for socket to become readable
	read = POLLIN,

	/// Wait for socket to become writable
	write = POLLOUT,

	/// Wait until socket has pending error condition
	error = POLLERR,
};

/// Socket shutdown types
enum shutdown_type: int
{
	/// Disable further receive operations
	receive = SHUT_RD,

	/// Disable further send operations
	send = SHUT_WR,

	/// Disable further send/receive operations
	both = SHUT_RDWR,
};

/// Wrapper for native socket handle. If application logic requires holding
/// native socket, use native_socket instead that wraps native_socket_handle
/// to std::unique_ptr to ensure closing handle when going out of scope.
///
/// \note Do not instances of this class directly, fetch native socket only if
/// PAL library does not provide typesafe wrapper for native OS socket API.
struct native_socket_handle
{
	/// Native OS socket handle type
	using type = __socket::handle;

	/// Invalid OS socket handle instance. It represents uninitialised socket.
	static constexpr type invalid = __socket::invalid_handle;

	/// Native OS socket handle instance
	type handle = invalid;

	constexpr native_socket_handle () = default;

	/// Construct uninitialised native_socket_handle instance
	constexpr native_socket_handle (std::nullptr_t) noexcept
	{ }

	/// Construct native_socket_handle from native OS \a handle
	constexpr native_socket_handle (type handle) noexcept
		: handle{handle}
	{ }

	/// Returns true if \a handle is initialised.
	constexpr explicit operator bool () const noexcept
	{
		return handle != invalid;
	}

	/// Represent this instance as fancy pointer
	constexpr native_socket_handle *operator-> () noexcept
	{
		return this;
	}

	/// Represent this instance as fancy pointer
	constexpr const native_socket_handle *operator-> () const noexcept
	{
		return this;
	}

	/// Returns true if \a a.handle == \a b.handle
	constexpr friend bool operator== (const native_socket_handle &a, const native_socket_handle &b) noexcept
	{
		return a.handle == b.handle;
	}

	/// Returns true if \a a.handle != \a b.handle
	constexpr friend bool operator!= (const native_socket_handle &a, const native_socket_handle &b) noexcept
	{
		return !(a == b);
	}

	struct close
	{
		using pointer = native_socket_handle;

		void operator() (pointer socket) const noexcept
		{
			#if __pal_net_posix
				while (true)
				{
					if (::close(socket->handle) == 0 || errno == EINTR)
					{
						return;
					}
				}
			#elif __pal_net_winsock
				::closesocket(socket->handle);
			#endif
		}
	};
};

/// Wrap native_socket_handle to std::unique_ptr
using native_socket = std::unique_ptr<native_socket_handle, native_socket_handle::close>;

/// Open and return new socket
result<native_socket> open (int domain, int type, int protocol = 0) noexcept;

/// Common socket types and constants
class socket_base
{
public:

	using message_flags = net::message_flags;
	static constexpr message_flags message_peek = message_flags::peek;
	static constexpr message_flags message_out_of_band = message_flags::out_of_band;
	static constexpr message_flags message_do_not_route = message_flags::do_not_route;
	static constexpr message_flags message_truncated = message_flags::truncated;

	using wait_type = net::wait_type;
	static constexpr wait_type wait_read = wait_type::read;
	static constexpr wait_type wait_write = wait_type::write;
	static constexpr wait_type wait_error = wait_type::error;

	using shutdown_type = net::shutdown_type;
	static constexpr shutdown_type shutdown_receive = shutdown_type::receive;
	static constexpr shutdown_type shutdown_send = shutdown_type::send;
	static constexpr shutdown_type shutdown_both = shutdown_type::both;

	/// Limit on length of queue of pending incoming connections
	static constexpr int max_listen_connections = SOMAXCONN;

	/// Maximum number of spans for vectored I/O
	static constexpr size_t io_vector_max_size = __socket::io_vector_max_size;

private:

	~socket_base () = default;
};

} // namespace pal::net
