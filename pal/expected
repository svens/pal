#pragma once // -*- C++ -*-

/**
 * \file pal/expected
 * Temporary std::expected implementation until standardized.
 *
 * \see http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0323r9.html
 */

#include <pal/__bits/lib>
#include <pal/uninitialized>
#include <pal/assert>
#include <stdexcept>
#include <type_traits>
#include <utility>


__pal_begin

/// \cond undocumented


template <typename T, typename E>
class expected;


// unexpected<E> {{{1
template <typename E>
class unexpected
{
private:

	template <typename U>
	static constexpr bool constructible_from_value =
		!std::is_same_v<std::remove_cvref_t<U>, std::in_place_t> &&
		!std::is_same_v<std::remove_cvref_t<U>, unexpected<E>>;

	template <typename U>
	static constexpr bool convertible_from_unexpected_v =
		!std::is_constructible_v<E, const unexpected<U> &> &&
		!std::is_constructible_v<E, unexpected<U> &> &&
		!std::is_constructible_v<E, const unexpected<U>> &&
		!std::is_constructible_v<E, unexpected<U>> &&
		!std::is_convertible_v<const unexpected<U> &, E> &&
		!std::is_convertible_v<unexpected<U> &, E> &&
		!std::is_convertible_v<const unexpected<U>, E> &&
		!std::is_convertible_v<unexpected<U>, E>
	;

public:

	static_assert(std::is_object_v<E>);
	static_assert(!std::is_array_v<E>);

	using error_type = E;


	//
	// Constructors
	//

	constexpr unexpected (const unexpected &) = default;
	constexpr unexpected (unexpected &&) = default;


	template <typename... Args>
		requires(std::is_constructible_v<E, Args...>)
	explicit constexpr unexpected (std::in_place_t, Args &&...args)
		noexcept(std::is_nothrow_constructible_v<E, Args...>)
		: value_{std::forward<Args>(args)...}
	{ }


	template <typename U>
		requires(std::is_constructible_v<E, U> && constructible_from_value<U>)
	explicit constexpr unexpected (U &&e)
		noexcept(std::is_nothrow_constructible_v<E, U>)
		: value_{std::forward<U>(e)}
	{ }


	template <typename U>
		requires(std::is_constructible_v<E, const U &> && convertible_from_unexpected_v<U>)
		explicit(!std::is_convertible_v<const U &, E>)
	constexpr unexpected (const unexpected<U> &that)
		noexcept(std::is_nothrow_constructible_v<E, const U &>)
		: value_{that.value_}
	{ }


	template <typename U>
		requires(std::is_constructible_v<E, U> && convertible_from_unexpected_v<U>)
		explicit(!std::is_convertible_v<U, E>)
	constexpr unexpected (unexpected<U> &&that)
		noexcept(std::is_nothrow_constructible_v<E, U &&>)
		: value_{std::move(that.value_)}
	{ }


	//
	// Assignments
	//

	constexpr unexpected &operator= (const unexpected &) = default;
	constexpr unexpected &operator= (unexpected &&) = default;


	template <typename U = E>
		requires(std::is_assignable_v<E, const U &>)
	constexpr unexpected &operator= (const unexpected<U> &that)
	{
		unexpected{that.value()}.swap(*this);
		return *this;
	}


	template <typename U = E>
		requires(std::is_assignable_v<E, U>)
	constexpr unexpected &operator= (unexpected<U> &&that)
	{
		unexpected{std::move(that.value())}.swap(*this);
		return *this;
	}


	//
	// Observers
	//

	constexpr const E &value () const & noexcept
	{
		return value_;
	}


	constexpr E &value () & noexcept
	{
		return value_;
	}


	constexpr const E &&value () const && noexcept
	{
		return std::move(value_);
	}


	constexpr E &&value () && noexcept
	{
		return std::move(value_);
	}


	//
	// Swap
	//

	void swap (unexpected &that)
		noexcept(std::is_nothrow_swappable_v<E>)
		#if !defined(__apple_build_version__)
			requires(std::is_swappable_v<E>)
		#else
			// TODO: expected ';' at end of declaration list
		#endif
	{
		using std::swap;
		swap(value_, that.value_);
	}


private:

	E value_;
	template <typename U> friend class unexpected;
};


template <typename E> unexpected(E) -> unexpected<E>;
template <typename E> unexpected(std::in_place_t, E) -> unexpected<E>;


template <typename E1, typename E2>
constexpr bool operator== (const unexpected<E1> &l, const unexpected<E2> &r)
{
	return l.value() == r.value();
}


template <typename E1, typename E2>
constexpr bool operator!= (const unexpected<E1> &l, const unexpected<E2> &r)
{
	return l.value() != r.value();
}


template <typename E>
	requires(std::is_swappable_v<E>)
void swap (unexpected<E> &l, unexpected<E> &r)
	noexcept(noexcept(l.swap(r)))
{
	l.swap(r);
}


// unexpect_t {{{1
struct unexpect_t
{
	explicit unexpect_t () = default;
};

inline constexpr unexpect_t unexpect{};


// bad_expected_access {{{1
template <typename E>
class bad_expected_access;


template <>
class bad_expected_access<void>: public std::exception
{
public:

	bad_expected_access () = default;
	virtual ~bad_expected_access() = default;

	const char *what () const noexcept override
	{
		return "bad expected access";
	}
};


template <typename E>
class bad_expected_access: public bad_expected_access<void>
{
public:

	using error_type = E;

	explicit bad_expected_access (error_type error)
		: error_(std::move(error))
	{ }

	const error_type &error () const &
	{
		return error_;
	}

	error_type &error () &
	{
		return error_;
	}

	const error_type &&error () const &&
	{
		return std::move(error_);
	}

	error_type &&error () &&
	{
		return std::move(error_);
	}

private:

	error_type error_;
};


// expected<T, E> internals {{{1
namespace __bits {

struct no_init_t {};
constexpr no_init_t no_init;

constexpr int deleted_v = 0;
constexpr int non_trivial_v = 1;
constexpr int trivial_v = 2;

// expected_storage_base {{{2

// non-trivial T, non-trivial E {{{3
template <typename T, typename E,
	bool = std::is_trivially_destructible_v<T>,
	bool = std::is_trivially_destructible_v<E>
>
struct expected_storage_base
{
	bool has_value;
	union
	{
		T value;
		pal::unexpected<E> unexpected;
		no_init_t no_init;
	};

	constexpr expected_storage_base () noexcept
		: has_value{true}
		, value{}
	{ }

	constexpr expected_storage_base (no_init_t) noexcept
		: has_value{false}
		, no_init{}
	{ }

	template <typename... Args>
		requires(std::is_constructible_v<T, Args &&...>)
	constexpr expected_storage_base (std::in_place_t, Args &&...args)
		: has_value{true}
		, value{std::forward<Args>(args)...}
	{ }

	template <typename... Args>
		requires(std::is_constructible_v<E, Args &&...>)
	constexpr expected_storage_base (unexpect_t, Args &&...args)
		: has_value{false}
		, unexpected{std::forward<Args>(args)...}
	{ }

	~expected_storage_base ()
	{
		if (has_value)
		{
			value.~T();
		}
		else
		{
			unexpected.~unexpected<E>();
		}
	}
};

// trivial T, trivial E {{{3
template <typename T, typename E>
struct expected_storage_base<T, E, true, true>
{
	bool has_value;
	union
	{
		T value;
		pal::unexpected<E> unexpected;
		no_init_t no_init;
	};

	constexpr expected_storage_base () noexcept
		: has_value{true}
		, value{}
	{ }

	constexpr expected_storage_base (no_init_t) noexcept
		: has_value{false}
		, no_init{}
	{ }

	template <typename... Args>
		requires(std::is_constructible_v<T, Args &&...>)
	constexpr expected_storage_base (std::in_place_t, Args &&...args)
		: has_value{true}
		, value{std::forward<Args>(args)...}
	{ }

	template <typename... Args>
		requires(std::is_constructible_v<E, Args &&...>)
	constexpr expected_storage_base (unexpect_t, Args &&...args)
		: has_value{false}
		, unexpected{std::forward<Args>(args)...}
	{ }

	expected_storage_base (const expected_storage_base &) = default;
	expected_storage_base (expected_storage_base &&) = default;
	expected_storage_base &operator= (const expected_storage_base &) = default;
	expected_storage_base &operator= (expected_storage_base &&) = default;
	~expected_storage_base () = default;
};

// trivial T, non-trivial E {{{3
template <typename T, typename E>
struct expected_storage_base<T, E, true, false>
{
	bool has_value;
	union
	{
		T value;
		pal::unexpected<E> unexpected;
		no_init_t no_init;
	};

	constexpr expected_storage_base () noexcept
		: has_value{true}
		, value{}
	{ }

	constexpr expected_storage_base (no_init_t) noexcept
		: has_value{false}
		, no_init{}
	{ }

	template <typename... Args>
		requires(std::is_constructible_v<T, Args &&...>)
	constexpr expected_storage_base (std::in_place_t, Args &&...args)
		: has_value{true}
		, value{std::forward<Args>(args)...}
	{ }

	template <typename... Args>
		requires(std::is_constructible_v<E, Args &&...>)
	constexpr expected_storage_base (unexpect_t, Args &&...args)
		: has_value{false}
		, unexpected{std::forward<Args>(args)...}
	{ }

	~expected_storage_base ()
	{
		if (!has_value)
		{
			unexpected.~unexpected<E>();
		}
	}
};

// non-trivial T, trivial E {{{3
template <typename T, typename E>
struct expected_storage_base<T, E, false, true>
{
	bool has_value;
	union
	{
		T value;
		pal::unexpected<E> unexpected;
		no_init_t no_init;
	};

	constexpr expected_storage_base () noexcept
		: has_value{true}
		, value{}
	{ }

	constexpr expected_storage_base (no_init_t) noexcept
		: has_value{false}
		, no_init{}
	{ }

	template <typename... Args>
		requires(std::is_constructible_v<T, Args &&...>)
	constexpr expected_storage_base (std::in_place_t, Args &&...args)
		: has_value{true}
		, value{std::forward<Args>(args)...}
	{ }

	template <typename... Args>
		requires(std::is_constructible_v<E, Args &&...>)
	constexpr expected_storage_base (unexpect_t, Args &&...args)
		: has_value{false}
		, unexpected{std::forward<Args>(args)...}
	{ }

	~expected_storage_base ()
	{
		if (has_value)
		{
			value.~T();
		}
	}
};

// void T, non-trivial E {{{3
template <typename E>
struct expected_storage_base<void, E, false, false>
{
	bool has_value;
	union
	{
		bool empty;
		pal::unexpected<E> unexpected;
		no_init_t no_init;
	};

	constexpr expected_storage_base () noexcept
		: has_value{true}
		, empty{}
	{ }

	constexpr expected_storage_base (no_init_t) noexcept
		: has_value{false}
		, no_init{}
	{ }

	constexpr expected_storage_base (std::in_place_t)
		: has_value{true}
		, empty{}
	{ }

	template <typename... Args>
		requires(std::is_constructible_v<E, Args &&...>)
	constexpr expected_storage_base (unexpect_t, Args &&...args)
		: has_value{false}
		, unexpected{std::forward<Args>(args)...}
	{ }

	expected_storage_base (const expected_storage_base &that)
		: has_value{that.has_value}
	{
		if (!has_value)
		{
			new(std::addressof(unexpected)) pal::unexpected<E>{that.unexpected};
		}
	}

	expected_storage_base &operator= (const expected_storage_base &that)
	{
		if (has_value && that.has_value)
		{
		}
		else if (!has_value && that.has_value)
		{
			unexpected.~unexpected<E>();
			has_value = true;
		}
		else if (has_value)
		{
			new(std::addressof(unexpected)) pal::unexpected<E>{that.unexpected.value()};
			has_value = false;
		}
		else
		{
			unexpected.value() = that.unexpected.value();
		}
		return *this;
	}

	~expected_storage_base ()
	{
		if (!has_value)
		{
			unexpected.~unexpected<E>();
		}
	}
};

// void T, trivial E {{{3
template <typename E>
struct expected_storage_base<void, E, false, true>
{
	bool has_value;
	union
	{
		bool empty;
		pal::unexpected<E> unexpected;
		no_init_t no_init;
	};

	constexpr expected_storage_base () noexcept
		: has_value{true}
		, empty{}
	{ }

	constexpr expected_storage_base (no_init_t) noexcept
		: has_value{false}
		, no_init{}
	{ }

	constexpr expected_storage_base (std::in_place_t)
		: has_value{true}
		, empty{}
	{ }

	template <typename... Args>
		requires(std::is_constructible_v<E, Args &&...>)
	constexpr expected_storage_base (unexpect_t, Args &&...args)
		: has_value{false}
		, unexpected{std::forward<Args>(args)...}
	{ }

	expected_storage_base (const expected_storage_base &) = default;
	expected_storage_base (expected_storage_base &&) = default;
	expected_storage_base &operator= (const expected_storage_base &) = default;
	expected_storage_base &operator= (expected_storage_base &&) = default;
	~expected_storage_base () = default;
};

//}}}3

// expected_storage<T, E> {{{2
template <typename T, typename E>
struct expected_storage: expected_storage_base<T, E>
{
	using expected_storage_base<T, E>::expected_storage_base;


	template <typename... Args>
	void value_ctor (Args &&...args)
		noexcept(std::is_void_v<T> || std::is_nothrow_constructible_v<T, Args...>)
	{
		if constexpr (!std::is_void_v<T>)
		{
			new(std::addressof(this->value)) T{std::forward<Args>(args)...};
		}
		this->has_value = true;
	}


	void value_dtor () noexcept
	{
		if constexpr (!std::is_void_v<T>)
		{
			this->value.~T();
		}
	}


	template <typename... Args>
	void unexpected_ctor (Args &&...args)
		noexcept(std::is_nothrow_constructible_v<unexpected<E>, std::in_place_t, Args...>)
	{
		new(std::addressof(this->unexpected)) unexpected<E>{std::in_place, std::forward<Args>(args)...};
		this->has_value = false;
	}


	void unexpected_dtor () noexcept
	{
		this->unexpected.~unexpected<E>();
	}


	void assign (const expected_storage &that)
		noexcept
		(
			noexcept(assign_value_value(that)) &&
			noexcept(assign_unexpected_value(that)) &&
			noexcept(assign_value_unexpected(that)) &&
			noexcept(assign_unexpected_unexpected(that))
		)
	{
		if (this->has_value && that.has_value)
		{
			assign_value_value(that);
		}
		else if (!this->has_value && that.has_value)
		{
			assign_unexpected_value(that);
		}
		else if (this->has_value)
		{
			assign_value_unexpected(that);
		}
		else
		{
			assign_unexpected_unexpected(that);
		}
	}


	void assign_value_value (const expected_storage &that)
		noexcept
		(
			std::is_void_v<T> ||
			std::is_nothrow_copy_assignable_v<T>
		)
	{
		if constexpr (!std::is_void_v<T>)
		{
			this->value = that.value;
		}
	}


	void assign_unexpected_value (const expected_storage &that)
		noexcept
		(
			std::is_void_v<T> ||
			(
				std::is_nothrow_copy_constructible_v<T> &&
				std::is_nothrow_move_constructible_v<T>
			)
		)
	{
		if constexpr (std::is_void_v<T>)
		{
			unexpected_dtor();
			this->has_value = true;
		}
		else if constexpr (std::is_nothrow_copy_constructible_v<T>)
		{
			unexpected_dtor();
			value_ctor(that.value);
		}
		else if constexpr (std::is_nothrow_move_constructible_v<T>)
		{
			auto tmp{that.value};
			unexpected_dtor();
			value_ctor(std::move(tmp));
		}
		else
		{
			auto tmp{this->unexpected.value()};
			unexpected_dtor();
			try
			{
				value_ctor(that.value);
			}
			catch (...)
			{
				unexpected_ctor(std::move(tmp));
				throw;
			}
		}
	}


	void assign_value_unexpected (const expected_storage &that)
		noexcept
		(
			std::is_void_v<T> ||
			(
				std::is_nothrow_copy_constructible_v<E> &&
				std::is_nothrow_move_constructible_v<E>
			)
		)
	{
		if constexpr (std::is_void_v<T>)
		{
			unexpected_ctor(that.unexpected.value());
		}
		else if constexpr (std::is_nothrow_copy_constructible_v<E>)
		{
			value_dtor();
			unexpected_ctor(that.unexpected.value());
		}
		else if constexpr (std::is_nothrow_move_constructible_v<E>)
		{
			auto tmp{that.unexpected.value()};
			value_dtor();
			unexpected_ctor(std::move(tmp));
		}
		else
		{
			auto tmp{this->value};
			value_dtor();
			try
			{
				unexpected_ctor(that.unexpected.value());
			}
			catch (...)
			{
				value_ctor(std::move(tmp));
				throw;
			}
		}
	}


	void assign_unexpected_unexpected (const expected_storage &that)
		noexcept(std::is_nothrow_copy_assignable_v<E>)
	{
		this->unexpected.value() = that.unexpected.value();
	}


	void assign (expected_storage &&that)
		noexcept
		(
			noexcept(assign_value_value(std::move(that))) &&
			noexcept(assign_unexpected_value(std::move(that))) &&
			noexcept(assign_value_unexpected(std::move(that))) &&
			noexcept(assign_unexpected_unexpected(std::move(that)))
		)
	{
		if (this->has_value && that.has_value)
		{
			assign_value_value(std::move(that));
		}
		else if (!this->has_value && that.has_value)
		{
			assign_unexpected_value(std::move(that));
		}
		else if (this->has_value)
		{
			assign_value_unexpected(std::move(that));
		}
		else
		{
			assign_unexpected_unexpected(std::move(that));
		}
	}


	void assign_value_value (expected_storage &&that)
		noexcept
		(
			std::is_void_v<T> ||
			std::is_nothrow_move_assignable_v<T>
		)
	{
		if constexpr (!std::is_void_v<T>)
		{
			this->value = std::move(that.value);
		}
	}


	void assign_unexpected_value (expected_storage &&that)
		noexcept
		(
			std::is_void_v<T> ||
			std::is_nothrow_move_constructible_v<T>
		)
	{
		if constexpr (std::is_void_v<T>)
		{
			unexpected_dtor();
			this->has_value = true;
		}
		else if constexpr (std::is_nothrow_move_constructible_v<T>)
		{
			unexpected_dtor();
			value_ctor(std::move(that.value));
		}
		else
		{
			auto tmp{std::move(this->unexpected.value())};
			unexpected_dtor();
			try
			{
				value_ctor(std::move(that.value));
			}
			catch (...)
			{
				unexpected_ctor(std::move(tmp));
				throw;
			}
		}
	}


	void assign_value_unexpected (expected_storage &&that)
		noexcept
		(
			std::is_void_v<T> ||
			std::is_nothrow_move_constructible_v<E>
		)
	{
		if constexpr (std::is_void_v<T>)
		{
			unexpected_ctor(std::move(that.unexpected.value()));
		}
		else if constexpr (std::is_nothrow_move_constructible_v<E>)
		{
			value_dtor();
			unexpected_ctor(std::move(that.unexpected.value()));
		}
		else
		{
			auto tmp{std::move(this->value)};
			value_dtor();
			try
			{
				unexpected_ctor(std::move(that.unexpected.value()));
			}
			catch (...)
			{
				value_ctor(std::move(tmp));
				throw;
			}
		}
	}


	void assign_unexpected_unexpected (expected_storage &&that)
		noexcept(std::is_nothrow_move_assignable_v<E>)
	{
		this->unexpected.value() = std::move(that.unexpected.value());
	}
};

// expected_copy_ctor {{{2
template <typename T, typename E>
constexpr int copy_constructible_v =
	(std::is_void_v<T> ? trivial_v : 0) +
	(std::is_copy_constructible_v<T> && std::is_copy_constructible_v<E>) +
	(std::is_trivially_copy_constructible_v<T> && std::is_trivially_copy_constructible_v<E>)
;

template <typename T, typename E, int = copy_constructible_v<T, E>>
struct expected_copy_ctor: expected_storage<T, E>
{
	using expected_storage<T, E>::expected_storage;
};

template <typename T, typename E>
struct expected_copy_ctor<T, E, deleted_v>: expected_storage<T, E>
{
	using expected_storage<T, E>::expected_storage;
	expected_copy_ctor () = default;
	expected_copy_ctor (expected_copy_ctor &&) = default;
	expected_copy_ctor &operator= (const expected_copy_ctor &) = default;
	expected_copy_ctor &operator= (expected_copy_ctor &&) = default;

	expected_copy_ctor (const expected_copy_ctor &) = delete;
};

template <typename T, typename E>
struct expected_copy_ctor<T, E, non_trivial_v>: expected_storage<T, E>
{
	using expected_storage<T, E>::expected_storage;
	expected_copy_ctor () = default;
	expected_copy_ctor (expected_copy_ctor &&) = default;
	expected_copy_ctor &operator= (const expected_copy_ctor &) = default;
	expected_copy_ctor &operator= (expected_copy_ctor &&) = default;

	expected_copy_ctor (const expected_copy_ctor &that)
		noexcept
		(
			noexcept(this->value_ctor(that.value)) &&
			noexcept(this->unexpected_ctor(that.unexpected.value()))
		)
		: expected_storage<T, E>{no_init}
	{
		if (that.has_value)
		{
			this->value_ctor(that.value);
		}
		else
		{
			this->unexpected_ctor(that.unexpected.value());
		}
	}
};

// expected_move_ctor {{{2
template <typename T, typename E>
constexpr int move_constructible_v =
	(std::is_void_v<T> ? trivial_v : 0) +
	(std::is_move_constructible_v<T> && std::is_move_constructible_v<E>) +
	(std::is_trivially_move_constructible_v<T> && std::is_trivially_move_constructible_v<E>)
;

template <typename T, typename E, int = move_constructible_v<T, E>>
struct expected_move_ctor: expected_copy_ctor<T, E>
{
	using expected_copy_ctor<T, E>::expected_copy_ctor;
};

template <typename T, typename E>
struct expected_move_ctor<T, E, deleted_v>: expected_copy_ctor<T, E>
{
	using expected_copy_ctor<T, E>::expected_copy_ctor;
	expected_move_ctor () = default;
	expected_move_ctor (const expected_move_ctor &) = default;
	expected_move_ctor &operator= (const expected_move_ctor &) = default;
	expected_move_ctor &operator= (expected_move_ctor &&) = default;

	expected_move_ctor (expected_move_ctor &&) = delete;
};

template <typename T, typename E>
struct expected_move_ctor<T, E, non_trivial_v>: expected_copy_ctor<T, E>
{
	using expected_copy_ctor<T, E>::expected_copy_ctor;
	expected_move_ctor () = default;
	expected_move_ctor (const expected_move_ctor &) = default;
	expected_move_ctor &operator= (const expected_move_ctor &) = default;
	expected_move_ctor &operator= (expected_move_ctor &&) = default;

	expected_move_ctor (expected_move_ctor &&that)
		noexcept
		(
			noexcept(this->value_ctor(std::move(that.value))) &&
			noexcept(this->unexpected_ctor(std::move(that.unexpected.value())))
		)
		: expected_copy_ctor<T, E>{no_init}
	{
		if (that.has_value)
		{
			this->value_ctor(std::move(that.value));
		}
		else
		{
			this->unexpected_ctor(std::move(that.unexpected.value()));
		}
	}
};

// expected_copy_assign {{{2
template <typename T, typename E>
constexpr int copy_assignable_v =
	(std::is_void_v<T> ? trivial_v : 0) +
	(std::is_copy_assignable_v<T> && std::is_copy_assignable_v<E>) +
	(std::is_trivially_copy_assignable_v<T> && std::is_trivially_copy_assignable_v<E>)
;

template <typename T, typename E, int = copy_assignable_v<T, E>>
struct expected_copy_assign: expected_move_ctor<T, E>
{
	using expected_move_ctor<T, E>::expected_move_ctor;
};

template <typename T, typename E>
struct expected_copy_assign<T, E, deleted_v>: expected_move_ctor<T, E>
{
	using expected_move_ctor<T, E>::expected_move_ctor;
	expected_copy_assign () = default;
	expected_copy_assign (const expected_copy_assign &) = default;
	expected_copy_assign (expected_copy_assign &&) = default;
	expected_copy_assign &operator= (expected_copy_assign &&) = default;

	expected_copy_assign &operator= (const expected_copy_assign &) = delete;
};

template <typename T, typename E>
struct expected_copy_assign<T, E, non_trivial_v>: expected_move_ctor<T, E>
{
	using expected_move_ctor<T, E>::expected_move_ctor;
	expected_copy_assign () = default;
	expected_copy_assign (const expected_copy_assign &) = default;
	expected_copy_assign (expected_copy_assign &&) = default;
	expected_copy_assign &operator= (expected_copy_assign &&) = default;

	expected_copy_assign &operator= (const expected_copy_assign &that)
		noexcept(noexcept(this->assign(that)))
	{
		this->assign(that);
		return *this;
	}
};

// expected_move_assign {{{2
template <typename T, typename E>
constexpr int move_assignable_v =
	(std::is_void_v<T> ? trivial_v : 0) +
	(std::is_move_assignable_v<T> && std::is_move_assignable_v<E>) +
	(std::is_trivially_move_assignable_v<T> && std::is_trivially_move_assignable_v<E>)
;

template <typename T, typename E, int = move_assignable_v<T, E>>
struct expected_move_assign: expected_copy_assign<T, E>
{
	using expected_copy_assign<T, E>::expected_copy_assign;
};

template <typename T, typename E>
struct expected_move_assign<T, E, deleted_v>: expected_copy_assign<T, E>
{
	using expected_copy_assign<T, E>::expected_copy_assign;
	expected_move_assign () = default;
	expected_move_assign (const expected_move_assign &) = default;
	expected_move_assign (expected_move_assign &&) = default;
	expected_move_assign &operator= (const expected_move_assign &) = default;

	expected_move_assign &operator= (expected_move_assign &&) = delete;
};

template <typename T, typename E>
struct expected_move_assign<T, E, non_trivial_v>: expected_copy_assign<T, E>
{
	using expected_copy_assign<T, E>::expected_copy_assign;
	expected_move_assign () = default;
	expected_move_assign (const expected_move_assign &) = default;
	expected_move_assign (expected_move_assign &&) = default;
	expected_move_assign &operator= (const expected_move_assign &) = default;

	expected_move_assign &operator= (expected_move_assign &&that)
		noexcept(noexcept(this->assign(std::move(that))))
	{
		this->assign(std::move(that));
		return *this;
	}
};

// }}}2

template <typename T, typename E>
using expected_impl = expected_move_assign<T, E>;

template <typename T, typename E, typename U, typename G, typename UR, typename GR>
static constexpr bool expected_converts_from_v =
	((std::is_void_v<T> && std::is_void_v<U>) || std::is_constructible_v<T, UR>) &&
	std::is_constructible_v<E, GR> &&

	!std::is_constructible_v<T, const expected<U, G> &>  &&
	!std::is_constructible_v<T,       expected<U, G> &>  &&
	!std::is_constructible_v<T, const expected<U, G> &&> &&
	!std::is_constructible_v<T,       expected<U, G> &&> &&

	!std::is_convertible_v<const expected<U, G> &,  T>   &&
	!std::is_convertible_v<      expected<U, G> &,  T>   &&
	!std::is_convertible_v<const expected<U, G> &&, T>   &&
	!std::is_convertible_v<      expected<U, G> &&, T>   &&

	!std::is_constructible_v<unexpected<E>, const expected<U, G> &>  &&
	!std::is_constructible_v<unexpected<E>,       expected<U, G> &>  &&
	!std::is_constructible_v<unexpected<E>, const expected<U, G> &&> &&
	!std::is_constructible_v<unexpected<E>,       expected<U, G> &&> &&

	!std::is_convertible_v<const expected<U, G> &,  unexpected<E>>   &&
	!std::is_convertible_v<      expected<U, G> &,  unexpected<E>>   &&
	!std::is_convertible_v<const expected<U, G> &&, unexpected<E>>   &&
	!std::is_convertible_v<      expected<U, G> &&, unexpected<E>>
;

template <typename T, typename E>
static constexpr bool expected_is_swappable_v =
	std::is_swappable_v<T> &&
	std::is_swappable_v<E> &&
	(
		std::is_move_constructible_v<T> ||
		std::is_move_constructible_v<E>
	)
	&&
	(
		std::is_nothrow_move_constructible_v<T> ||
		std::is_nothrow_move_constructible_v<E>
	)
;

template <typename E>
static constexpr bool expected_is_swappable_v<void, E> =
	std::is_swappable_v<E> &&
	std::is_move_constructible_v<E>
;

template <typename T, typename E>
static constexpr bool expected_is_nothrow_swappable_v =
	std::is_nothrow_move_constructible_v<T> &&
	std::is_nothrow_swappable_v<T> &&
	std::is_nothrow_move_constructible_v<E> &&
	std::is_nothrow_swappable_v<E>
;

template <typename E>
static constexpr bool expected_is_nothrow_swappable_v<void, E> =
	std::is_nothrow_move_constructible_v<E> &&
	std::is_nothrow_swappable_v<E>
;


} // namespace __bits


// expected<T, E> {{{1
template <typename T, typename E>
class expected: private __bits::expected_impl<T, E>
{
private:

	using impl = __bits::expected_impl<T, E>;

public:

	static_assert(!std::is_reference_v<T>);
	static_assert(!std::is_same_v<std::remove_cv_t<T>, std::in_place_t>);
	static_assert(!std::is_same_v<std::remove_cv_t<T>, unexpect_t>);
	static_assert(!std::is_same_v<std::remove_cv_t<T>, unexpected<E>>);

	using value_type = T;
	using error_type = E;
	using unexpected_type = unexpected<E>;

	template <typename U>
	using rebind = expected<U, error_type>;

	constexpr expected () = default;
	constexpr expected (const expected &) = default;
	constexpr expected (expected &&) = default;
	expected &operator= (const expected &) = default;
	expected &operator= (expected &&) = default;


	// Constructors {{{2

	template <typename U, typename G>
		requires
		(
			__bits::expected_converts_from_v<
				T, E, U, G,
				std::add_lvalue_reference_t<const U>,
				const G &
			>
		)
		explicit
		(
			(
				std::is_void_v<T> &&
				std::is_void_v<U> &&
				!std::is_convertible_v<std::add_lvalue_reference_t<const U>, T>
			)
			||
			!std::is_convertible_v<const G &, E>
		)
	constexpr expected (const expected<U, G> &that)
		: impl{__bits::no_init}
	{
		if (that)
		{
			if constexpr (std::is_void_v<U>)
			{
				impl::value_ctor();
			}
			else
			{
				impl::value_ctor(*that);
			}
		}
		else
		{
			impl::unexpected_ctor(that.error());
		}
	}


	template <typename U, typename G>
		requires
		(
			__bits::expected_converts_from_v<
				T, E, U, G,
				std::add_rvalue_reference_t<U>,
				G &&
			>
		)
		explicit
		(
			(
				std::is_void_v<T> &&
				std::is_void_v<U> &&
				!std::is_convertible_v<std::add_rvalue_reference_t<U>, T>
			)
			||
			!std::is_convertible_v<G &&, E>
		)
	constexpr expected (expected<U, G> &&that)
		: impl{__bits::no_init}
	{
		if (that)
		{
			if constexpr (std::is_void_v<U>)
			{
				impl::value_ctor();
			}
			else
			{
				impl::value_ctor(std::move(*that));
			}
		}
		else
		{
			impl::unexpected_ctor(std::move(that.error()));
		}
	}


	template <typename U = T>
		requires
		(
			!std::is_void_v<U> &&
			std::is_constructible_v<T, U &&> &&
			!std::is_same_v<std::remove_cvref_t<U>, std::in_place_t> &&
			!std::is_same_v<std::remove_cvref_t<U>, expected<T, E>> &&
			!std::is_same_v<std::remove_cvref_t<U>, unexpected<E>>
		)
	explicit(!std::is_convertible_v<U &&, T>)
	constexpr expected (U &&v)
		: impl{std::in_place, std::forward<U>(v)}
	{ }


	template <typename G = E>
		requires(std::is_constructible_v<E, const G &>)
	explicit(!std::is_convertible_v<const G &, E>)
	constexpr expected (const unexpected<G> &e)
		noexcept(std::is_nothrow_constructible_v<E, const G &>)
		: impl{unexpect, e.value()}
	{ }


	template <typename G = E>
		requires(std::is_constructible_v<E, G &&>)
	explicit(!std::is_convertible_v<G &&, E>)
	constexpr expected (unexpected<G> &&e)
		noexcept(std::is_nothrow_constructible_v<E, G &&>)
		: impl{unexpect, std::move(e.value())}
	{ }


	template <typename... Args>
		requires
		(
			(std::is_void_v<T> && sizeof...(Args) == 0) ||
			(!std::is_void_v<T> && std::is_constructible_v<T, Args...>)
		)
	explicit constexpr expected (std::in_place_t tag, Args &&...args)
		noexcept(std::is_nothrow_constructible_v<T, Args...>)
		: impl{tag, std::forward<Args>(args)...}
	{ }


	template <typename... Args>
		requires(std::is_constructible_v<E, Args...>)
	explicit constexpr expected (unexpect_t tag, Args &&...args)
		noexcept(std::is_nothrow_constructible_v<E, Args...>)
		: impl{tag, std::forward<Args>(args)...}
	{ }


	// Assignment {{{2

	template <typename G = E>
		requires
		(
			std::is_nothrow_copy_constructible_v<G> &&
			std::is_copy_assignable_v<G>
		)
	expected &operator= (const unexpected<G> &e)
	{
		if (impl::has_value)
		{
			impl::value_dtor();
			impl::unexpected_ctor(e.value());
		}
		else
		{
			impl::unexpected.value() = e.value();
		}
		return *this;
	}


	template <typename G = E>
		requires
		(
			std::is_nothrow_move_constructible_v<G> &&
			std::is_move_assignable_v<G>
		)
	expected &operator= (unexpected<G> &&e)
	{
		if (impl::has_value)
		{
			impl::value_dtor();
			impl::unexpected_ctor(std::move(e.value()));
		}
		else
		{
			impl::unexpected.value() = std::move(e.value());
		}
		return *this;
	}


	template <typename U = T>
		requires
		(
			!std::is_void_v<T> &&
			!std::is_same_v<expected<T, E>, std::remove_cvref_t<U>> &&
			!std::conjunction_v<std::is_scalar<T>, std::is_same<T, std::decay_t<U>>> &&
			std::is_constructible_v<T, U> &&
			std::is_assignable_v<std::add_lvalue_reference_t<T>, U> &&
			std::is_nothrow_move_constructible_v<E>
		)
	expected &operator= (U &&v)
	{
		if (impl::has_value)
		{
			impl::value = std::forward<U>(v);
		}
		else
		{
			if constexpr (std::is_nothrow_constructible_v<T, U>)
			{
				impl::unexpected_dtor();
				impl::value_ctor(std::forward<U>(v));
			}
			else
			{
				auto tmp{std::move(impl::unexpected.value())};
				impl::unexpected_dtor();
				try
				{
					impl::value_ctor(std::forward<U>(v));
				}
				catch (...)
				{
					impl::unexpected_ctor(std::move(tmp));
					throw;
				}
			}
		}
		return *this;
	}


	template <typename U = T>
		requires(std::is_void_v<U>)
	void emplace ()
	{
		if (!impl::has_value)
		{
			impl::unexpected_dtor();
			impl::value_ctor();
		}
	}


	template <typename U = T, typename... Args>
		requires
		(
			!std::is_void_v<T> &&
			std::is_constructible_v<T, Args &&...>
		)
	U &emplace (Args &&...args)
	{
		if (impl::has_value)
		{
			impl::value_dtor();
			impl::value_ctor(std::forward<Args>(args)...);
		}
		else
		{
			if constexpr (std::is_nothrow_constructible_v<T, Args...>)
			{
				impl::unexpected_dtor();
				impl::value_ctor(std::forward<Args>(args)...);
			}
			else if constexpr (std::is_nothrow_move_constructible_v<T>)
			{
				T tmp{std::forward<Args>(args)...};
				impl::unexpected_dtor();
				impl::value_ctor(std::move(tmp));
			}
			else
			{
				auto tmp{std::move(impl::unexpected.value())};
				impl::unexpected_dtor();
				try
				{
					impl::value_ctor(std::forward<Args>(args)...);
				}
				catch (...)
				{
					impl::unexpected_ctor(std::move(tmp));
					throw;
				}
			}
		}
		return **this;
	}


	// Swap {{{2

	template <typename U = T, typename G = E>
		requires(__bits::expected_is_swappable_v<U, G>)
	void swap (expected &that)
		noexcept(__bits::expected_is_nothrow_swappable_v<U, G>)
	{
		if (impl::has_value && that.impl::has_value)
		{
			swap_value_value(that);
		}
		else if (!impl::has_value && that.impl::has_value)
		{
			swap_unexpected_value(that);
		}
		else if (impl::has_value)
		{
			swap_value_unexpected(that);
		}
		else
		{
			swap_unexpected_unexpected(that);
		}
	}


	// Observers {{{2

	constexpr bool has_value () const noexcept
	{
		return impl::has_value;
	}


	constexpr explicit operator bool () const noexcept
	{
		return has_value();
	}


	template <typename U = T>
		requires(!std::is_void_v<U>)
	constexpr const U *operator-> () const noexcept
	{
		return std::addressof(impl::value);
	}


	template <typename U = T>
		requires(!std::is_void_v<U>)
	constexpr U *operator-> () noexcept
	{
		return std::addressof(impl::value);
	}


	template <typename U = T>
		requires(!std::is_void_v<U>)
	constexpr const U &operator* () const &
	{
		return impl::value;
	}


	template <typename U = T>
		requires(!std::is_void_v<U>)
	constexpr U &operator* () &
	{
		return impl::value;
	}


	template <typename U = T>
		requires(!std::is_void_v<U>)
	constexpr const U &&operator* () const &&
	{
		return std::move(impl::value);
	}


	template <typename U = T>
		requires(!std::is_void_v<U>)
	constexpr U &&operator* () &&
	{
		return std::move(impl::value);
	}


	constexpr const E &error () const &
	{
		return impl::unexpected.value();
	}


	constexpr E &error () &
	{
		return impl::unexpected.value();
	}


	constexpr const E &&error () const &&
	{
		return std::move(impl::unexpected.value());
	}


	constexpr E &&error () &&
	{
		return std::move(impl::unexpected.value());
	}


	template <typename U = T>
		requires(!std::is_void_v<U>)
	constexpr const U &value () const &
	{
		return require_value(), impl::value;
	}


	template <typename U = T>
		requires(!std::is_void_v<U>)
	constexpr U &value () &
	{
		return require_value(), impl::value;
	}


	template <typename U = T>
		requires(!std::is_void_v<U>)
	constexpr const U &&value () const &&
	{
		return require_value(), std::move(impl::value);
	}


	template <typename U = T>
		requires(!std::is_void_v<U>)
	constexpr U &&value () &&
	{
		return require_value(), std::move(impl::value);
	}


	template <typename U>
		requires(std::is_copy_constructible_v<T> && std::is_convertible_v<U, T>)
	constexpr T value_or (U &&v) const &
	{
		return impl::has_value ? impl::value : static_cast<T>(std::forward<U>(v));
	}


	template <typename U>
		requires(std::is_move_constructible_v<T> && std::is_convertible_v<U, T>)
	constexpr T value_or (U &&v) &&
	{
		return impl::has_value ? std::move(impl::value) : static_cast<T>(std::forward<U>(v));
	}

	//}}}2


private:

	constexpr bool require_value () const
	{
		if (!impl::has_value)
		{
			throw bad_expected_access<E>(error());
		}
		return true;
	}

	void swap_value_value (expected &that)
	{
		if constexpr (!std::is_void_v<T>)
		{
			using std::swap;
			swap(impl::value, that.impl::value);
		}
	}

	void swap_unexpected_unexpected (expected &that)
	{
		using std::swap;
		swap(impl::unexpected.value(), that.impl::unexpected.value());
	}

	void swap_unexpected_value (expected &that)
	{
		that.swap(*this);
	}

	void swap_value_unexpected (expected &that)
	{
		if constexpr (std::is_void_v<T>)
		{
			impl::unexpected_ctor(std::move(that.impl::unexpected.value()));
			that.impl::unexpected_dtor();
			that.impl::value_ctor();
		}
		else if constexpr (
			std::is_nothrow_move_constructible_v<T> &&
			std::is_nothrow_move_constructible_v<E>)
		{
			auto tmp{std::move(that.impl::unexpected.value())};
			that.impl::unexpected_dtor();
			that.impl::value_ctor(std::move(impl::value));
			impl::value_dtor();
			impl::unexpected_ctor(std::move(tmp));
		}
		else if constexpr (std::is_nothrow_move_constructible_v<E>)
		{
			auto tmp{std::move(that.impl::unexpected.value())};
			that.impl::unexpected_dtor();
			try
			{
				that.impl::value_ctor(std::move(impl::value));
			}
			catch (...)
			{
				that.impl::unexpected_ctor(std::move(tmp));
				throw;
			}
			impl::value_dtor();
			impl::unexpected_ctor(std::move(tmp));
		}
		else if constexpr (std::is_nothrow_move_constructible_v<T>)
		{
			auto tmp{std::move(impl::value)};
			impl::value_dtor();
			try
			{
				impl::unexpected_ctor(std::move(that.impl::unexpected.value()));
			}
			catch (...)
			{
				impl::value_ctor(std::move(tmp));
				throw;
			}
			that.impl::unexpected_dtor();
			that.impl::value_ctor(std::move(tmp));
		}
		else
		{
			static_assert
			(
				std::is_nothrow_move_constructible_v<T> ||
				std::is_nothrow_move_constructible_v<E>
			);
		}
	}
};


template <typename T, typename E, typename U, typename G>
constexpr bool operator== (const expected<T, E> &l, const expected<U, G> &r)
{
	if (l.has_value() && r.has_value())
	{
		if constexpr (std::is_void_v<T> && std::is_void_v<U>)
		{
			return true;
		}
		else
		{
			return *l == *r;
		}
	}
	else if (!l.has_value() && !r.has_value())
	{
		return l.error() == r.error();
	}
	return false;
}


template <typename T, typename E, typename U, typename G>
constexpr bool operator!= (const expected<T, E> &l, const expected<U, G> &r)
{
	return !(l == r);
}


template <typename T, typename E, typename U>
constexpr bool operator== (const expected<T, E> &l, const U &r)
{
	return l.has_value() && *l == r;
}


template <typename T, typename E, typename U>
constexpr bool operator== (const U &l, const expected<T, E> &r)
{
	return r == l;
}


template <typename T, typename E, typename U>
constexpr bool operator!= (const expected<T, E> &l, const U &r)
{
	return !(l == r);
}


template <typename T, typename E, typename U>
constexpr bool operator!= (const U &l, const expected<T, E> &r)
{
	return r != l;
}


template <typename T, typename E, typename G>
constexpr bool operator== (const expected<T, E> &l, const unexpected<G> &r)
{
	return !l.has_value() && l.error() == r.value();
}


template <typename T, typename E, typename G>
constexpr bool operator== (const unexpected<G> &l, const expected<T, E> &r)
{
	return r == l;
}


template <typename T, typename E, typename G>
constexpr bool operator!= (const expected<T, E> &l, const unexpected<G> &r)
{
	return l.has_value() || l.error() != r.value();
}


template <typename T, typename E, typename G>
constexpr bool operator!= (const unexpected<G> &l, const expected<T, E> &r)
{
	return r != l;
}


template <typename T, typename E>
	requires(__bits::expected_is_swappable_v<T, E>)
void swap (expected<T, E> &l, expected<T, E> &r)
	noexcept(noexcept(l.swap(r)))
{
	l.swap(r);
}

//}}}1


/// \endcond

__pal_end
