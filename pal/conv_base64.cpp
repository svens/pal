#include <pal/conv>

namespace pal {

namespace {

constexpr uint8_t pad = '=';

} // namespace

std::byte *base64::encode (const std::byte *first, const std::byte *last, std::byte *out) noexcept
{
	static constexpr uint8_t mask = 0b00111111;
	static constexpr uint8_t map[] =
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"abcdefghijklmnopqrstuvwxyz"
		"0123456789"
		"+/";

	auto it = reinterpret_cast<uint8_t *>(out);
	auto next = reinterpret_cast<const uint8_t *>(first);
	auto end = reinterpret_cast<const uint8_t *>(last);

	const auto mod = (end - next) % 3;
	end -= mod;

	for (/**/;  next != end;  next += 3)
	{
		*it++ = map[next[0] >> 2];
		*it++ = map[((next[0] << 4) | (next[1] >> 4)) & mask];
		*it++ = map[((next[1] << 2) | (next[2] >> 6)) & mask];
		*it++ = map[next[2] & mask];
	}

	if (mod == 1)
	{
		*it++ = map[next[0] >> 2];
		*it++ = map[((next[0] << 4)) & mask];
		*it++ = pad;
		*it++ = pad;
	}
	else if (mod == 2)
	{
		*it++ = map[next[0] >> 2];
		*it++ = map[((next[0] << 4) | (next[1] >> 4)) & mask];
		*it++ = map[(next[1] << 2) & mask];
		*it++ = pad;
	}

	return reinterpret_cast<std::byte *>(it);
}

std::byte *base64::decode (const std::byte *first, const std::byte *last, std::byte *out) noexcept
{
	static constexpr uint8_t map[] =
	{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x3f,
		0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
		0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
		0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	};

	if ((last - first) % 4 != 0)
	{
		return nullptr;
	}

	auto it = reinterpret_cast<uint8_t *>(out);
	auto next = reinterpret_cast<const uint8_t *>(first);
	auto end = reinterpret_cast<const uint8_t *>(last);

	const int mod = (end[-1] == pad) + (end[-2] == pad);
	end = next + ((end - next - mod) / 4) * 4;

	uint8_t b0, b1, b2, b3;

	while (next != end)
	{
		b0 = map[next[0]];
		b1 = map[next[1]];
		b2 = map[next[2]];
		b3 = map[next[3]];
		if (b0 != 0xff && b1 != 0xff && b2 != 0xff && b3 != 0xff)
		{
			auto v = (b0 << 18) | (b1 << 12) | (b2 << 6) | b3;
			*it++ = (v >> 16) & 0xff;
			*it++ = (v >> 8) & 0xff;
			*it++ = v & 0xff;
			next += 4;
		}
		else
		{
			return nullptr;
		}
	}

	if (mod == 1)
	{
		b0 = map[next[0]];
		b1 = map[next[1]];
		b2 = map[next[2]];
		if (b0 != 0xff && b1 != 0xff && b2 != 0xff)
		{
			auto v = (b0 << 18) | (b1 << 12) | (b2 << 6);
			*it++ = (v >> 16) & 0xff;
			*it++ = (v >> 8) & 0xff;
		}
		else
		{
			return nullptr;
		}
	}
	else if (mod == 2)
	{
		b0 = map[next[0]];
		b1 = map[next[1]];
		if (b0 != 0xff && b1 != 0xff)
		{
			*it++ = ((b0 << 18) | (b1 << 12)) >> 16;
		}
		else
		{
			return nullptr;
		}
	}

	return reinterpret_cast<std::byte *>(it);
}

} // namespace pal
