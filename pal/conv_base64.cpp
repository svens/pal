#include <pal/conv>
#include <array>


__pal_begin


conv_result to_base64 (const char *first, const char *last, char *out) noexcept
{
	static constexpr uint8_t map[] =
		"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
		"abcdefghijklmnopqrstuvwxyz"
		"0123456789"
		"+/";

	conv_result result{last, nullptr};

	auto p = reinterpret_cast<const uint8_t *>(first);
	auto e = reinterpret_cast<const uint8_t *>(last);

	const auto mod = (e - p) % 3;
	e -= mod;

	for (/**/;  p != e;  p += 3)
	{
		*out++ = map[p[0] >> 2];
		*out++ = map[((p[0] << 4) | (p[1] >> 4)) & 0b00111111];
		*out++ = map[((p[1] << 2) | (p[2] >> 6)) & 0b00111111];
		*out++ = map[p[2] & 0b00111111];
	}

	if (mod == 1)
	{
		*out++ = map[p[0] >> 2];
		*out++ = map[((p[0] << 4)) & 0b00111111];
		*out++ = '=';
		*out++ = '=';
	}
	else if (mod == 2)
	{
		*out++ = map[p[0] >> 2];
		*out++ = map[((p[0] << 4) | (p[1] >> 4)) & 0b00111111];
		*out++ = map[(p[1] << 2) & 0b00111111];
		*out++ = '=';
	}

	result.last_out = out;
	return result;
}


conv_result from_base64 (const char *first, const char *last, char *out) noexcept
{
	static constexpr std::array<uint8_t, 256> map =
	{
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x3f,
		0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
		0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
		0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	};

	int pad = last >= first + 2 ? (last[-1] == '=') + (last[-2] == '=') : 0;
	const auto end = first + ((last - first - pad) / 4) * 4;

	while (first != end)
	{
		auto b0 = map[first[0]], b1 = map[first[1]], b2 = map[first[2]], b3 = map[first[3]];
		if (b0 != 0xff && b1 != 0xff && b2 != 0xff && b3 != 0xff)
		{
			auto v = (b0 << 18) | (b1 << 12) | (b2 << 6) | b3;
			*out++ = (v >> 16) & 0xff;
			*out++ = (v >> 8) & 0xff;
			*out++ = v & 0xff;
			first += 4;
		}
		else
		{
			break;
		}
	}

	for (auto it = first;  it != last;  ++it)
	{
		if (*it != '=' && map[*it] == 0xff)
		{
			return {it, out};
		}
	}

	if (pad == 1)
	{
		auto v = (map[first[0]] << 18) | (map[first[1]] << 12) | (map[first[2]] << 6);
		*out++ = (v >> 16) & 0xff;
		*out++ = (v >> 8) & 0xff;
		first += 3;
	}
	else if (pad == 2)
	{
		*out++ = ((map[first[0]] << 18) | (map[first[1]] << 12)) >> 16;
		first += 2;
	}

	return {first + pad, out};
}


__pal_end
