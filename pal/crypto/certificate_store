#pragma once // -*- C++ -*-

/**
 * \file pal/crypto/certificate_store
 * Certificate store
 */

#include <pal/crypto/certificate>
#include <pal/result>
#include <span>
#include <string_view>

namespace pal::crypto {

class certificate_store
{
public:

	certificate_store () noexcept = default;

	template <typename Data>
	static result<certificate_store> from_pkcs12 (const Data &pkcs12, const char *password = nullptr) noexcept
	{
		return import_pkcs12(std::as_bytes(std::span{pkcs12}), password);
	}

	/// Returns true if \a this certificate store represents unspecified store
	bool is_null () const noexcept
	{
		return impl_ == nullptr;
	}

	/// Returns true if \a this certificate store represents unspecified store
	explicit operator bool () const noexcept
	{
		return !is_null();
	}

	bool empty () const noexcept;

	class const_iterator;

	const_iterator begin () const noexcept;
	const_iterator end () const noexcept;

private:

	struct impl_type;
	using impl_ptr = std::shared_ptr<impl_type>;
	impl_ptr impl_{};

	certificate_store (impl_ptr &&impl) noexcept
		: impl_{std::move(impl)}
	{ }

	static result<certificate_store> import_pkcs12 (const std::span<const std::byte> &pkcs12, const char *password) noexcept;
};

class certificate_store::const_iterator
{
public:

	using iterator_category = std::forward_iterator_tag;
	using value_type = certificate;
	using pointer = const certificate *;
	using reference = const certificate &;
	using difference_type = std::ptrdiff_t;

	const_iterator () = default;
	const_iterator (const const_iterator &) = default;
	const_iterator &operator= (const const_iterator &) = default;

	bool operator== (const const_iterator &that) const noexcept
	{
		return entry_.impl_ == that.entry_.impl_;
	}

	bool operator!= (const const_iterator &that) const noexcept
	{
		return !operator==(that);
	}

	const_iterator &operator++ () noexcept;

	const_iterator operator++ (int) noexcept
	{
		auto result = *this;
		this->operator++();
		return result;
	}

	reference operator* () const noexcept
	{
		return entry_;
	}

	pointer operator-> () const noexcept
	{
		return &entry_;
	}

private:

	certificate entry_{};

	const_iterator (const impl_type &store) noexcept;

	friend class certificate_store;
};

inline certificate_store::const_iterator certificate_store::begin () const noexcept
{
	return {*impl_};
}

inline certificate_store::const_iterator certificate_store::end () const noexcept
{
	return {};
}

} // pal::crypto
