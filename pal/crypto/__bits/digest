#pragma once // -*- C++ -*-

#include <pal/__bits/lib>

#if __pal_os_linux
	#include <openssl/hmac.h>
	#include <openssl/md5.h>
	#include <openssl/sha.h>
	#include <memory>
#elif __pal_os_macos
	#include <CommonCrypto/CommonDigest.h>
	#include <CommonCrypto/CommonHMAC.h>
#elif __pal_os_windows
	#include <windows.h>
	#include <bcrypt.h>
	#include <algorithm>
	#pragma comment(lib, "bcrypt")
#endif


__pal_begin


namespace crypto::__bits {


#if __pal_os_linux //{{{1

template <typename Impl>
struct hash_context: Impl
{
	hash_context () noexcept;
	void update (const void *data, size_t size) noexcept;
	void finish (void *digest, size_t size) noexcept;
};

struct md5_algorithm
{
	using hash = hash_context<::MD5_CTX>;
};

struct sha1_algorithm
{
	using hash = hash_context<::SHA_CTX>;
};

struct sha256_algorithm
{
	using hash = hash_context<::SHA256_CTX>;
};

struct __SHA384_CTX: ::SHA512_CTX {};

struct sha384_algorithm
{
	using hash = hash_context<__SHA384_CTX>;
};

struct sha512_algorithm
{
	using hash = hash_context<::SHA512_CTX>;
};

#elif __pal_os_macos //{{{1

template <typename Impl>
struct hash_context: Impl
{
	hash_context () noexcept;
	void update (const void *data, size_t size) noexcept;
	void finish (void *digest, size_t size) noexcept;
};

struct md5_algorithm
{
	using hash = hash_context<::CC_MD5_CTX>;
};

struct sha1_algorithm
{
	using hash = hash_context<::CC_SHA1_CTX>;
};

struct sha256_algorithm
{
	using hash = hash_context<::CC_SHA256_CTX>;
};

struct __CC_SHA384_CTX: CC_SHA512_CTX {};

struct sha384_algorithm
{
	using hash = hash_context<__CC_SHA384_CTX>;
};

struct sha512_algorithm
{
	using hash = hash_context<::CC_SHA512_CTX>;
};

#elif __pal_os_windows //{{{1

template <typename Impl>
struct context_type
{
	BCRYPT_HASH_HANDLE handle{};

	context_type ();
	~context_type () noexcept;
	context_type (const context_type &that) noexcept;

	context_type (context_type &&that) noexcept
		: handle{std::exchange(that.handle, {})}
	{ }

	context_type &operator= (context_type that) noexcept
	{
		std::swap(handle, that.handle);
		return *this;
	}

	void update (const void *data, size_t size) noexcept;
	void finish (void *digest, size_t size) noexcept;
};

struct md5_algorithm
{
	static constexpr LPCWSTR id = BCRYPT_MD5_ALGORITHM;
	using hash = context_type<md5_algorithm>;
};

struct sha1_algorithm
{
	static constexpr LPCWSTR id = BCRYPT_SHA1_ALGORITHM;
	using hash = context_type<sha1_algorithm>;
};

struct sha256_algorithm
{
	static constexpr LPCWSTR id = BCRYPT_SHA256_ALGORITHM;
	using hash = context_type<sha256_algorithm>;
};

struct sha384_algorithm
{
	static constexpr LPCWSTR id = BCRYPT_SHA384_ALGORITHM;
	using hash = context_type<sha384_algorithm>;
};

struct sha512_algorithm
{
	static constexpr LPCWSTR id = BCRYPT_SHA512_ALGORITHM;
	using hash = context_type<sha512_algorithm>;
};

#endif //}}}1


template <typename Context> constexpr size_t digest_size_v = 0U;
template <> inline constexpr size_t digest_size_v<md5_algorithm> = 16U;
template <> inline constexpr size_t digest_size_v<sha1_algorithm> = 20U;
template <> inline constexpr size_t digest_size_v<sha256_algorithm> = 32U;
template <> inline constexpr size_t digest_size_v<sha384_algorithm> = 48U;
template <> inline constexpr size_t digest_size_v<sha512_algorithm> = 64U;


} // namespace crypto::__bits


__pal_end
